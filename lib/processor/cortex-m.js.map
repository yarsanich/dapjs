{"version":3,"sources":["processor/cortex-m.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;EAqBE;;;;;;;;;;;;;;;AAEF,8BAA6B;AAY7B;;GAEG;AACH,IAAM,eAAe,GAAG,KAAK,CAAC;AAC9B;;GAEG;AACH,IAAM,gBAAgB,GAAG,MAAM,CAAC;AAChC;;GAEG;AACH,IAAM,sBAAsB,GAAG,EAAE,CAAC;AAElC;;GAEG;AACH;IAA6B,2BAAG;IAAhC;;IA+LA,CAAC;IA7LW,6BAAW,GAAnB;QACI,OAAO,IAAI,CAAC,UAAU,yBAAsB,4CAAsC,CAAC,CAAC;IACxF,CAAC;IAES,yCAAuB,GAAjC,UAAkC,QAAgB;QAC9C,OAAO,IAAI,CAAC,iBAAiB,yBAAsB,QAAQ,CAAC;aAC3D,MAAM,CAAC,IAAI,CAAC,gBAAgB,wBAAqB,CAAC;aAClD,MAAM,CAAC,IAAI,CAAC,gBAAgB,wBAAqB,CAAC,CAAC;IACxD,CAAC;IAES,0CAAwB,GAAlC,UAAmC,QAAgB,EAAE,KAAa;QAC9D,OAAO,IAAI,CAAC,iBAAiB,yBAAsB,KAAK,CAAC;aACxD,MAAM,CAAC,IAAI,CAAC,iBAAiB,yBAAsB,QAAQ,qBAAmB,CAAC,CAAC,CAAC;IACtF,CAAC;IAED;;;OAGG;IACI,0BAAQ,GAAf;QAAA,iBAwBC;QAvBG,OAAO,IAAI,CAAC,SAAS,wBAAqB;aACzC,IAAI,CAAC,UAAA,KAAK;YACP,IAAI,KAAgB,CAAC;YAErB,IAAI,KAAK,wBAAqB;gBAAE,KAAK,iBAAmB,CAAC;iBACpD,IAAI,KAAK,uBAAoB;gBAAE,KAAK,mBAAqB,CAAC;iBAC1D,IAAI,KAAK,sBAAmB;gBAAE,KAAK,gBAAkB,CAAC;;gBACtD,KAAK,kBAAoB,CAAC;YAE/B,IAAI,KAAK,4BAAuB,EAAE;gBAC9B,2DAA2D;gBAC3D,OAAO,KAAI,CAAC,SAAS,wBAAqB;qBACzC,IAAI,CAAC,UAAA,QAAQ;oBACV,IAAI,QAAQ,4BAAuB,IAAI,CAAC,CAAC,QAAQ,6BAAwB,CAAC,EAAE;wBACxE,qBAAuB;qBAC1B;yBAAM;wBACH,OAAO,KAAK,CAAC;qBAChB;gBACL,CAAC,CAAC,CAAC;aACN;iBAAM;gBACH,OAAO,KAAK,CAAC;aAChB;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;OAGG;IACI,0BAAQ,GAAf;QACI,OAAO,IAAI,CAAC,SAAS,wBAAqB;aACzC,IAAI,CAAC,UAAA,KAAK;YACP,OAAO,CAAC,CAAC,CAAC,KAAK,sBAAmB,CAAC,CAAC;QACxC,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;OAKG;IACI,sBAAI,GAAX,UAAY,IAAoB,EAAE,OAAmB;QAArD,iBAYC;QAZW,qBAAA,EAAA,WAAoB;QAAE,wBAAA,EAAA,WAAmB;QACjD,OAAO,IAAI,CAAC,QAAQ,EAAE;aACrB,IAAI,CAAC,UAAA,MAAM;YACR,IAAI,MAAM;gBAAE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAErC,OAAO,KAAI,CAAC,UAAU,yBAAsB,4CAAsC,iBAAmB,CAAC;iBACrG,IAAI,CAAC;gBACF,IAAI,CAAC,IAAI;oBAAE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;gBAEpC,OAAO,KAAI,CAAC,SAAS,CAAC,cAAM,OAAA,KAAI,CAAC,QAAQ,EAAE,EAAf,CAAe,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;YAC/D,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;OAKG;IACI,wBAAM,GAAb,UAAc,IAAoB,EAAE,OAAmB;QAAvD,iBAaC;QAba,qBAAA,EAAA,WAAoB;QAAE,wBAAA,EAAA,WAAmB;QACnD,OAAO,IAAI,CAAC,QAAQ,EAAE;aACrB,IAAI,CAAC,UAAA,MAAM;YACR,IAAI,CAAC,MAAM;gBAAE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YAEtC,OAAO,KAAI,CAAC,UAAU,wBAAqB,8BAAgC,iBAAkB,CAAC;iBAC7F,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,WAAW,EAAE,EAAlB,CAAkB,CAAC;iBAC9B,IAAI,CAAC;gBACF,IAAI,CAAC,IAAI;oBAAE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;gBAEpC,OAAO,KAAI,CAAC,SAAS,CAAC,cAAM,OAAA,KAAI,CAAC,QAAQ,EAAE,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,CAAC,MAAM,EAAP,CAAO,CAAC,EAAvC,CAAuC,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;YACvF,CAAC,CAAC,CAAC;QACP,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;OAIG;IACI,kCAAgB,GAAvB,UAAwB,QAAsB;QAA9C,iBAaC;QAZG,OAAO,IAAI,CAAC,gBAAgB,CAAC;YACzB,IAAI,CAAC,iBAAiB,yBAAsB,QAAQ,CAAC;YACrD,IAAI,CAAC,gBAAgB,wBAAqB;SAC7C,CAAC;aACD,IAAI,CAAC,UAAA,OAAO;YACT,IAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACzB,IAAI,CAAC,CAAC,KAAK,uBAAqB,CAAC,EAAE;gBAC/B,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;aACzC;YAED,OAAO,KAAI,CAAC,SAAS,wBAAqB,CAAC;QAC/C,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;OAIG;IACI,mCAAiB,GAAxB,UAAyB,SAAyB;QAAlD,iBAQC;QAPG,IAAI,KAAK,GAAsB,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QAEnD,SAAS,CAAC,OAAO,CAAC,UAAA,QAAQ;YACtB,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,UAAA,OAAO,IAAI,OAAA,KAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAI,OAAO,SAAE,MAAM,IAAnB,CAAoB,CAAC,EAApE,CAAoE,CAAC,CAAC;QACxG,CAAC,CAAC,CAAC;QAEH,OAAO,KAAK,CAAC;IACjB,CAAC;IAED;;;;;OAKG;IACI,mCAAiB,GAAxB,UAAyB,QAAsB,EAAE,KAAa;QAC1D,OAAO,IAAI,CAAC,gBAAgB,CAAC;YACzB,IAAI,CAAC,iBAAiB,yBAAsB,KAAK,CAAC;YAClD,IAAI,CAAC,iBAAiB,yBAAsB,QAAQ,qBAAmB,CAAC;YACxE,IAAI,CAAC,gBAAgB,wBAAqB;SAC7C,CAAC;aACD,IAAI,CAAC,UAAA,OAAO;YACT,IAAM,KAAK,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;YACzB,IAAI,CAAC,CAAC,KAAK,uBAAqB,CAAC,EAAE;gBAC/B,MAAM,IAAI,KAAK,CAAC,oBAAoB,CAAC,CAAC;aACzC;QACL,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;;;OAQG;IACI,yBAAO,GAAd,UAAe,OAAe,EAAE,IAAiB,EAAE,YAAoB,EAAE,cAAsB,EAAE,YAAkC;QAAnI,iBA2BC;QA3BgG,6BAAA,EAAA,eAAuB,OAAO,GAAG,CAAC;QAAE,mBAAsB;aAAtB,UAAsB,EAAtB,qBAAsB,EAAtB,IAAsB;YAAtB,kCAAsB;;QAEvJ,oDAAoD;QACpD,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,KAAK,gBAAgB,EAAE;YAC5C,IAAM,OAAO,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACjD,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAClB,OAAO,CAAC,GAAG,CAAC,CAAC,gBAAgB,CAAC,EAAE,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;YACjD,IAAI,GAAG,OAAO,CAAC;SAClB;QAED,0CAA0C;QAC1C,IAAM,QAAQ,GAAG;YACb,IAAI,CAAC,wBAAwB,cAAkB,YAAY,CAAC;YAC5D,IAAI,CAAC,wBAAwB,cAAkB,cAAc,CAAC;YAC9D,IAAI,CAAC,wBAAwB,cAAkB,YAAY,CAAC;SAC/D,CAAC;QAEF,0CAA0C;QAC1C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,MAAM,EAAE,sBAAsB,CAAC,EAAE,CAAC,EAAE,EAAE;YACzE,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,wBAAwB,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;SACjE;QAED,OAAO,IAAI,CAAC,IAAI,EAAE,CAAC,kBAAkB;aACpC,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,EAA/B,CAA+B,CAAC,CAAC,sBAAsB;aAClE,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,UAAU,CAAC,OAAO,EAAE,IAAI,CAAC,EAA9B,CAA8B,CAAC,CAAC,gCAAgC;aAC3E,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAlB,CAAkB,CAAC,CAAC,qCAAqC;aACpE,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,SAAS,CAAC,cAAM,OAAA,KAAI,CAAC,QAAQ,EAAE,EAAf,CAAe,EAAE,GAAG,EAAE,eAAe,CAAC,EAA3D,CAA2D,CAAC,CAAC,CAAC,gDAAgD;IAC9H,CAAC;IACL,cAAC;AAAD,CA/LA,AA+LC,CA/L4B,SAAG,GA+L/B;AA/LY,0BAAO","file":"cortex-m.js","sourcesContent":["/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { ADI } from \"../dap\";\nimport {\n    DebugRegister,\n    CoreRegister,\n    DhcsrMask,\n    DfsrMask,\n    DcrsrMask,\n    CoreState\n} from \"./enums\";\nimport { Processor } from \"./\";\nimport { DAPOperation } from \"../proxy\";\n\n/**\n * @hidden\n */\nconst EXECUTE_TIMEOUT = 10000;\n/**\n * @hidden\n */\nconst BKPT_INSTRUCTION = 0xBE2A;\n/**\n * @hidden\n */\nconst GENERAL_REGISTER_COUNT = 12;\n\n/**\n * Cortex M class\n */\nexport class CortexM extends ADI implements Processor {\n\n    private enableDebug() {\n        return this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN);\n    }\n\n    protected readCoreRegisterCommand(register: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRSR, register)\n        .concat(this.readMem32Command(DebugRegister.DHCSR))\n        .concat(this.readMem32Command(DebugRegister.DCRDR));\n    }\n\n    protected writeCoreRegisterCommand(register: number, value: number): DAPOperation[] {\n        return this.writeMem32Command(DebugRegister.DCRDR, value)\n        .concat(this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR));\n    }\n\n    /**\n     * Get the state of the processor core\n     * @returns Promise of CoreState\n     */\n    public getState(): Promise<CoreState> {\n        return this.readMem32(DebugRegister.DHCSR)\n        .then(dhcsr => {\n            let state: CoreState;\n\n            if (dhcsr & DhcsrMask.S_LOCKUP) state = CoreState.LOCKUP;\n            else if (dhcsr & DhcsrMask.S_SLEEP) state = CoreState.SLEEPING;\n            else if (dhcsr & DhcsrMask.S_HALT) state = CoreState.DEBUG;\n            else state = CoreState.RUNNING;\n\n            if (dhcsr & DhcsrMask.S_RESET_ST) {\n                // The core has been reset, check if an instruction has run\n                return this.readMem32(DebugRegister.DHCSR)\n                .then(newDhcsr => {\n                    if (newDhcsr & DhcsrMask.S_RESET_ST && !(newDhcsr & DhcsrMask.S_RETIRE_ST)) {\n                        return CoreState.RESET;\n                    } else {\n                        return state;\n                    }\n                });\n            } else {\n                return state;\n            }\n        });\n    }\n\n    /**\n     * Whether the target is halted\n     * @returns Promise of halted state\n     */\n    public isHalted(): Promise<boolean> {\n        return this.readMem32(DebugRegister.DHCSR)\n        .then(dhcsr => {\n            return !!(dhcsr & DhcsrMask.S_HALT);\n        });\n    }\n\n    /**\n     * Halt the target\n     * @param wait Wait until halted before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public halt(wait: boolean = true, timeout: number = 0): Promise<void> {\n        return this.isHalted()\n        .then(halted => {\n            if (halted) return Promise.resolve();\n\n            return this.writeMem32(DebugRegister.DHCSR, DhcsrMask.DBGKEY | DhcsrMask.C_DEBUGEN | DhcsrMask.C_HALT)\n            .then(() => {\n                if (!wait) return Promise.resolve();\n\n                return this.waitDelay(() => this.isHalted(), 100, timeout);\n            });\n        });\n    }\n\n    /**\n     * Resume a target\n     * @param wait Wait until resumed before returning\n     * @param timeout Milliseconds to wait before aborting wait\n     * @returns Promise\n     */\n    public resume(wait: boolean = true, timeout: number = 0) {\n        return this.isHalted()\n        .then(halted => {\n            if (!halted) return Promise.resolve();\n\n            return this.writeMem32(DebugRegister.DFSR, DfsrMask.DWTTRAP | DfsrMask.BKPT | DfsrMask.HALTED)\n            .then(() => this.enableDebug())\n            .then(() => {\n                if (!wait) return Promise.resolve();\n\n                return this.waitDelay(() => this.isHalted().then(result => !result), 100, timeout);\n            });\n        });\n    }\n\n    /**\n     * Read from a core register\n     * @param register The register to read\n     * @returns Promise of value\n     */\n    public readCoreRegister(register: CoreRegister): Promise<number> {\n        return this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRSR, register),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ])\n        .then(results => {\n            const dhcsr = results[0];\n            if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n                throw new Error(\"Register not ready\");\n            }\n\n            return this.readMem32(DebugRegister.DCRDR);\n        });\n    }\n\n    /**\n     * Read an array of core registers\n     * @param registers The registers to read\n     * @returns Promise of register values in an array\n     */\n    public readCoreRegisters(registers: CoreRegister[]): Promise<number[]> {\n        let chain: Promise<number[]> = Promise.resolve([]);\n\n        registers.forEach(register => {\n            chain = chain.then(results => this.readCoreRegister(register).then(result => [...results, result]));\n        });\n\n        return chain;\n    }\n\n    /**\n     * Write to a core register\n     * @param register The register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public writeCoreRegister(register: CoreRegister, value: number): Promise<void> {\n        return this.transferSequence([\n            this.writeMem32Command(DebugRegister.DCRDR, value),\n            this.writeMem32Command(DebugRegister.DCRSR, register | DcrsrMask.REGWnR),\n            this.readMem32Command(DebugRegister.DHCSR)\n        ])\n        .then(results => {\n            const dhcsr = results[0];\n            if (!(dhcsr & DhcsrMask.S_REGRDY)) {\n                throw new Error(\"Register not ready\");\n            }\n        });\n    }\n\n    /**\n     * Exucute code at a specified memory address\n     * @param address The address to put the code\n     * @param code The code to use\n     * @param stackPointer The stack pointer to use\n     * @param programCounter The program counter to use\n     * @param linkRegister The link register to use (defaults to address + 1)\n     * @param registers Values to add to the general purpose registers, R0, R1, R2, etc.\n     */\n    public execute(address: number, code: Uint32Array, stackPointer: number, programCounter: number, linkRegister: number = address + 1, ...registers: number[]): Promise<void> {\n\n        // Ensure a breakpoint exists at the end of the code\n        if (code[code.length - 1] !== BKPT_INSTRUCTION) {\n            const newCode = new Uint32Array(code.length + 1);\n            newCode.set(code);\n            newCode.set([BKPT_INSTRUCTION], code.length - 1);\n            code = newCode;\n        }\n\n        // Create sequence of core register writes\n        const sequence = [\n            this.writeCoreRegisterCommand(CoreRegister.SP, stackPointer),\n            this.writeCoreRegisterCommand(CoreRegister.PC, programCounter),\n            this.writeCoreRegisterCommand(CoreRegister.LR, linkRegister)\n        ];\n\n        // Add in register values R0, R1, R2, etc.\n        for (let i = 0; i < Math.min(registers.length, GENERAL_REGISTER_COUNT); i++) {\n            sequence.push(this.writeCoreRegisterCommand(i, registers[i]));\n        }\n\n        return this.halt() // Halt the target\n        .then(() => this.transferSequence(sequence)) // Write the registers\n        .then(() => this.writeBlock(address, code)) // Write the code to the address\n        .then(() => this.resume(false)) // Resume the target, without waiting\n        .then(() => this.waitDelay(() => this.isHalted(), 100, EXECUTE_TIMEOUT)); // Wait for the target to halt on the breakpoint\n    }\n}\n"],"sourceRoot":"../../src"}