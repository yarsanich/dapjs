{"version":3,"sources":["dap/adi.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;;;;;;;EAqBE;;AAGF,kCAAyD;AAIzD,gDAA6D;AAE7D;;GAEG;AACH,IAAM,eAAe,GAAG,IAAI,CAAC;AAC7B;;GAEG;AACH,IAAM,sBAAsB,GAAG,KAAK,CAAC;AAErC;;GAEG;AACH;IAkBI,aAAY,cAAiC,EAAE,IAAuC,EAAE,cAAgD;QAAzF,qBAAA,EAAA,sBAAuC;QAAE,+BAAA,EAAA,iBAAyB,mCAAuB;QACpI,SAAS,WAAW,CAAC,IAAuB;YACxC,OAAQ,IAAkB,CAAC,IAAI,KAAK,SAAS,CAAC;QAClD,CAAC;QACD,IAAI,CAAC,KAAK,GAAG,WAAW,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC,IAAI,gBAAQ,CAAC,cAAc,EAAE,IAAI,EAAE,cAAc,CAAC,CAAC,CAAC,CAAC,cAAc,CAAC;IACnH,CAAC;IAES,mBAAK,GAAf,UAAgB,OAAe;QAC3B,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,OAAO;YAChC,UAAU,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QACjC,CAAC,CAAC,CAAC;IACP,CAAC;IAED;;;;;;OAMG;IACO,uBAAS,GAAnB,UAAoB,EAA0B,EAAE,KAAmB,EAAE,OAAmB;QAAxF,iBAuBC;QAvB+C,sBAAA,EAAA,WAAmB;QAAE,wBAAA,EAAA,WAAmB;QACpF,IAAI,OAAO,GAAY,IAAI,CAAC;QAE5B,IAAM,KAAK,GAAG,UAAC,SAAkB;YAC7B,IAAI,CAAC,OAAO;gBAAE,OAAO,OAAO,CAAC,OAAO,EAAE,CAAC;YACvC,OAAO,SAAS;gBACZ,CAAC,CAAC,OAAO,CAAC,OAAO,EAAE;gBACnB,CAAC,CAAC,KAAI,CAAC,KAAK,CAAC,KAAK,CAAC;qBAClB,IAAI,CAAC,EAAE,CAAC;qBACR,IAAI,CAAC,KAAK,CAAC,CAAC;QACrB,CAAC,CAAC;QAEF,OAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC/B,IAAI,OAAO,GAAG,CAAC,EAAE;gBACb,UAAU,CAAC;oBACP,OAAO,GAAG,KAAK,CAAC;oBAChB,MAAM,CAAC,gBAAgB,CAAC,CAAC;gBAC7B,CAAC,EAAE,OAAO,CAAC,CAAC;aACf;YAED,OAAO,KAAK,CAAC,KAAK,CAAC;iBAClB,IAAI,CAAC,cAAM,OAAA,OAAO,EAAE,EAAT,CAAS,CAAC,CAAC;QAC3B,CAAC,CAAC,CAAC;IACP,CAAC;IAES,8BAAgB,GAA1B,UAA2B,MAAqB;QAC5C,wBAAwB;QACxB,IAAI,MAAM,CAAC,MAAM,KAAK,CAAC;YAAE,OAAO,MAAM,CAAC,CAAC,CAAC,CAAC;QAE1C,yBAAyB;QACzB,IAAI,MAAM,GAAW,CAAC,CAAC;QACvB,KAAoB,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM,EAAE;YAAvB,IAAM,KAAK,eAAA;YACZ,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC;SAC1B;QAED,oBAAoB;QACpB,IAAM,MAAM,GAAG,IAAI,WAAW,CAAC,MAAM,CAAC,CAAC;QACvC,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC3C,MAAM,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;YACzB,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC;SACzB;QAED,OAAO,MAAM,CAAC;IAClB,CAAC;IAES,2BAAa,GAAvB,UAAwB,QAAgB;QACpC,OAAO,CAAC;gBACJ,IAAI,cAAsB;gBAC1B,IAAI,eAAe;gBACnB,QAAQ,UAAA;aACX,CAAC,CAAC;IACP,CAAC;IAES,4BAAc,GAAxB,UAAyB,QAAgB,EAAE,KAAa;QACpD,IAAI,QAAQ,mBAAsB,EAAE;YAChC,IAAI,KAAK,KAAK,IAAI,CAAC,eAAe,EAAE;gBAChC,OAAO,EAAE,CAAC;aACb;YACD,IAAI,CAAC,eAAe,GAAG,KAAK,CAAC;SAChC;QAED,OAAO,CAAC;gBACJ,IAAI,eAAuB;gBAC3B,IAAI,eAAe;gBACnB,QAAQ,UAAA;gBACR,KAAK,OAAA;aACR,CAAC,CAAC;IACP,CAAC;IAES,2BAAa,GAAvB,UAAwB,QAAgB;QACpC,IAAM,OAAO,GAAG,CAAC,QAAQ,yBAAuB,CAAC,GAAG,CAAC,QAAQ,sBAA2B,CAAC,CAAC;QAE1F,OAAO,IAAI,CAAC,cAAc,iBAAoB,OAAO,CAAC,CAAC,MAAM,CAAC;YAC1D,IAAI,cAAsB;YAC1B,IAAI,gBAAgB;YACpB,QAAQ,UAAA;SACX,CAAC,CAAC;IACP,CAAC;IAES,4BAAc,GAAxB,UAAyB,QAAgB,EAAE,KAAa;QACpD,IAAI,QAAQ,gBAAmB,EAAE;YAC7B,IAAI,KAAK,KAAK,IAAI,CAAC,QAAQ,EAAE;gBACzB,OAAO,EAAE,CAAC;aACb;YACD,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;SACzB;QAED,IAAM,OAAO,GAAG,CAAC,QAAQ,yBAAuB,CAAC,GAAG,CAAC,QAAQ,sBAA2B,CAAC,CAAC;QAE1F,OAAO,IAAI,CAAC,cAAc,iBAAoB,OAAO,CAAC,CAAC,MAAM,CAAC;YAC1D,IAAI,eAAuB;YAC3B,IAAI,gBAAgB;YACpB,QAAQ,UAAA;YACR,KAAK,OAAA;SACR,CAAC,CAAC;IACP,CAAC;IAES,8BAAgB,GAA1B,UAA2B,QAAgB;QACvC,OAAO,IAAI,CAAC,cAAc,cAAiB,uCAA+B,CAAC;aAC1E,MAAM,CAAC,IAAI,CAAC,cAAc,cAAiB,QAAQ,CAAC,CAAC;aACrD,MAAM,CAAC,IAAI,CAAC,aAAa,cAAgB,CAAC,CAAC;IAChD,CAAC;IAES,+BAAiB,GAA3B,UAA4B,QAAgB,EAAE,KAAa;QACvD,OAAO,IAAI,CAAC,cAAc,cAAiB,uCAA+B,CAAC;aAC1E,MAAM,CAAC,IAAI,CAAC,cAAc,cAAiB,QAAQ,CAAC,CAAC;aACrD,MAAM,CAAC,IAAI,CAAC,cAAc,eAAiB,KAAK,CAAC,CAAC,CAAC;IACxD,CAAC;IAES,8BAAgB,GAA1B,UAA2B,QAAgB;QACvC,OAAO,IAAI,CAAC,cAAc,cAAiB,uCAA+B,CAAC;aAC1E,MAAM,CAAC,IAAI,CAAC,cAAc,cAAiB,QAAQ,CAAC,CAAC;aACrD,MAAM,CAAC,IAAI,CAAC,aAAa,cAAgB,CAAC,CAAC;IAChD,CAAC;IAES,+BAAiB,GAA3B,UAA4B,QAAgB,EAAE,KAAa;QACvD,OAAO,IAAI,CAAC,cAAc,cAAiB,uCAA+B,CAAC;aAC1E,MAAM,CAAC,IAAI,CAAC,cAAc,cAAiB,QAAQ,CAAC,CAAC;aACrD,MAAM,CAAC,IAAI,CAAC,cAAc,eAAiB,KAAe,CAAC,CAAC,CAAC;IAClE,CAAC;IAES,8BAAgB,GAA1B,UAA2B,UAA4B;QAAvD,iBAeC;QAdG,uCAAuC;QACvC,IAAI,MAAM,GAAmB,EAAE,CAAC;QAChC,MAAM,GAAG,MAAM,CAAC,MAAM,OAAb,MAAM,EAAW,UAAU,CAAC,CAAC;QAEtC,IAAI,KAAK,GAA2B,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;;YAIpD,IAAM,QAAQ,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,OAAK,KAAK,CAAC,cAAc,CAAC,CAAC;YAC7D,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,UAAA,OAAO,IAAI,OAAA,KAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAI,OAAO,SAAE,MAAM,IAAnB,CAAoB,CAAC,EAAlE,CAAkE,CAAC,CAAC;;;QAHtG,iEAAiE;QACjE,OAAO,MAAM,CAAC,MAAM;;SAGnB;QAED,OAAO,KAAK;aACX,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,KAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAA7B,CAA6B,CAAC,CAAC;IACnD,CAAC;IAED;;;OAGG;IACI,qBAAO,GAAd;QAAA,iBAeC;QAdG,IAAM,IAAI,GAAG,6DAAqD,CAAC;QAEnE,OAAO,IAAI,CAAC,KAAK,CAAC,OAAO,EAAE;aAC1B,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,MAAM,eAAkB,EAA7B,CAA6B,CAAC;aACzC,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,gBAAgB,CAAC;YAC9B,KAAI,CAAC,cAAc,kCAAuC;YAC1D,KAAI,CAAC,cAAc,6BAAmC;YACtD,KAAI,CAAC,cAAc,oBAAuB,4DAAqD,CAAC;SACnG,CAAC,EAJU,CAIV,CAAC;YACH,8CAA8C;aAC7C,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,SAAS,CAAC;YACvB,OAAO,KAAI,CAAC,MAAM,mBAAsB;iBACvC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,KAAK,IAAI,CAAC,EAA1B,CAA0B,CAAC,CAAC;QAChD,CAAC,CAAC,EAHU,CAGV,CAAC,CAAC;IACR,CAAC;IAED;;;OAGG;IACI,wBAAU,GAAjB;QACI,OAAO,IAAI,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC;IACnC,CAAC;IAED;;;OAGG;IACI,uBAAS,GAAhB;QAAA,iBAIC;QAHG,OAAO,IAAI,CAAC,UAAU,EAAE;aACvB,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,KAAK,CAAC,GAAG,CAAC,EAAf,CAAe,CAAC;aAC3B,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,OAAO,EAAE,EAAd,CAAc,CAAC,CAAC;IAChC,CAAC;IAED;;;OAGG;IACI,mBAAK,GAAZ;QACI,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC;IAC9B,CAAC;IAED;;;;OAIG;IACI,oBAAM,GAAb,UAAc,QAAoB;QAC9B,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACvD,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC,CAAC;IAC/B,CAAC;IAED;;;;;OAKG;IACI,qBAAO,GAAd,UAAe,QAAoB,EAAE,KAAa;QAC9C,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;aAC/D,IAAI,CAAC,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC,CAAC;IAC3B,CAAC;IAED;;;;OAIG;IACI,oBAAM,GAAb,UAAc,QAAoB;QAC9B,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,CAAC;aACvD,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC,CAAC;IAC/B,CAAC;IAED;;;;;OAKG;IACI,qBAAO,GAAd,UAAe,QAAoB,EAAE,KAAa;QAC9C,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;aAC/D,IAAI,CAAC,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC,CAAC;IAC3B,CAAC;IAED;;;;OAIG;IACI,uBAAS,GAAhB,UAAiB,QAAgB;QAC7B,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;aAC1D,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC,CAAC;IAC/B,CAAC;IAED;;;;;OAKG;IACI,wBAAU,GAAjB,UAAkB,QAAgB,EAAE,KAAa;QAC7C,KAAK,GAAG,KAAe,IAAI,CAAC,CAAC,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QACpD,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;aAClE,IAAI,CAAC,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC,CAAC;IAC3B,CAAC;IAED;;;;OAIG;IACI,uBAAS,GAAhB,UAAiB,QAAgB;QAC7B,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;aAC1D,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,MAAM,CAAC,CAAC,CAAC,EAAT,CAAS,CAAC,CAAC;IAC/B,CAAC;IAED;;;;;OAKG;IACI,wBAAU,GAAjB,UAAkB,QAAgB,EAAE,KAAa;QAC7C,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,IAAI,CAAC,iBAAiB,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;aAClE,IAAI,CAAC,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC,CAAC;IAC3B,CAAC;IAED;;;;;OAKG;IACI,uBAAS,GAAhB,UAAiB,QAAgB,EAAE,KAAa;QAAhD,iBAkBC;QAjBG,IAAI,KAAK,GAA2B,IAAI,CAAC,gBAAgB,CAAC;YACtD,IAAI,CAAC,cAAc,cAAiB,uCAA+B,CAAC;YACpE,IAAI,CAAC,cAAc,cAAiB,QAAQ,CAAC;SAChD,CAAC;aACD,IAAI,CAAC,cAAM,OAAA,EAAE,EAAF,CAAE,CAAC,CAAC;QAEhB,gDAAgD;QAChD,IAAI,SAAS,GAAG,KAAK,CAAC;;YAElB,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,OAAK,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;YAC5E,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,UAAA,OAAO,IAAI,OAAA,KAAI,CAAC,KAAK,CAAC,aAAa,+BAAiC,SAAS,CAAC;iBAChG,IAAI,CAAC,UAAA,MAAM,IAAI,OAAI,OAAO,SAAE,MAAM,IAAnB,CAAoB,CAAC,EADP,CACO,CAAC,CAAC;YACvC,SAAS,IAAI,SAAS,CAAC;;;QAJ3B,OAAO,SAAS,GAAG,CAAC;;SAKnB;QAED,OAAO,KAAK;aACX,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,KAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAA7B,CAA6B,CAAC,CAAC;IACnD,CAAC;IAED;;;;;OAKG;IACI,wBAAU,GAAjB,UAAkB,QAAgB,EAAE,MAAmB;QAAvD,iBAgBC;QAfG,IAAI,KAAK,GAAkB,IAAI,CAAC,gBAAgB,CAAC;YAC7C,IAAI,CAAC,cAAc,cAAiB,uCAA+B,CAAC;YACpE,IAAI,CAAC,cAAc,cAAiB,QAAQ,CAAC;SAChD,CAAC;aACD,IAAI,CAAC,cAAM,OAAA,SAAS,EAAT,CAAS,CAAC,CAAC;QAEvB,qDAAqD;QACrD,IAAI,KAAK,GAAG,CAAC,CAAC;;YAEV,IAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,OAAK,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC,CAAC;YAChF,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,KAAK,CAAC,aAAa,+BAAiC,KAAK,CAAC,EAA/D,CAA+D,CAAC,CAAC;YAC1F,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,OAAK,KAAK,CAAC,SAAS,GAAG,CAAC,CAAC,CAAC;;;QAHlD,OAAO,KAAK,GAAG,MAAM,CAAC,MAAM;;SAI3B;QAED,OAAO,KAAK,CAAC;IACjB,CAAC;IAED;;;;;OAKG;IACI,0BAAY,GAAnB,UAAoB,QAAgB,EAAE,KAAa;QAAnD,iBAeC;QAdG,IAAI,KAAK,GAA2B,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,CAAC;QACxD,2CAA2C;QAC3C,IAAI,SAAS,GAAG,KAAK,CAAC;QACtB,IAAI,KAAK,GAAG,CAAC,CAAC;;YAEV,IAAM,YAAY,GAAG,QAAQ,GAAG,KAAK,GAAG,CAAC,CAAC;YAC1C,IAAM,aAAa,GAAG,eAAe,GAAG,CAAC,CAAC,YAAY,IAAI,CAAC,CAAC,GAAG,sBAAsB,CAAC,CAAC;YACvF,IAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,SAAS,EAAE,aAAa,CAAC,CAAC;YACrD,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,UAAA,OAAO,IAAI,OAAA,KAAI,CAAC,SAAS,CAAC,YAAY,EAAE,SAAS,CAAC,CAAC,IAAI,CAAC,UAAA,MAAM,IAAI,OAAI,OAAO,SAAE,MAAM,IAAnB,CAAoB,CAAC,EAA5E,CAA4E,CAAC,CAAC;YAC5G,SAAS,IAAI,SAAS,CAAC;YACvB,KAAK,IAAI,SAAS,CAAC;;QANvB,OAAO,SAAS,GAAG,CAAC;;SAOnB;QACD,OAAO,KAAK;aACX,IAAI,CAAC,UAAA,MAAM,IAAI,OAAA,KAAI,CAAC,gBAAgB,CAAC,MAAM,CAAC,EAA7B,CAA6B,CAAC,CAAC;IACnD,CAAC;IAED;;;;;OAKG;IACI,2BAAa,GAApB,UAAqB,QAAgB,EAAE,MAAmB;QAA1D,iBAYC;QAXG,IAAI,KAAK,GAAkB,OAAO,CAAC,OAAO,EAAE,CAAC;QAC7C,2CAA2C;QAC3C,IAAI,KAAK,GAAG,CAAC,CAAC;;YAEV,IAAM,aAAa,GAAG,QAAQ,GAAG,KAAK,GAAG,CAAC,CAAC;YAC3C,IAAM,aAAa,GAAG,eAAe,GAAG,CAAC,CAAC,aAAa,IAAI,CAAC,CAAC,GAAG,sBAAsB,CAAC,CAAC;YACxF,IAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,KAAK,EAAE,KAAK,GAAG,aAAa,CAAC,CAAC;YACzD,KAAK,GAAG,KAAK,CAAC,IAAI,CAAC,cAAM,OAAA,KAAI,CAAC,UAAU,CAAC,aAAa,EAAE,KAAK,CAAC,EAArC,CAAqC,CAAC,CAAC;YAChE,KAAK,IAAI,aAAa,CAAC;;QAL3B,OAAO,KAAK,GAAG,MAAM,CAAC,MAAM;;SAM3B;QACD,OAAO,KAAK,CAAC;IACjB,CAAC;IACL,UAAC;AAAD,CAhZA,AAgZC,IAAA;AAhZY,kBAAG","file":"adi.js","sourcesContent":["/*\n* DAPjs\n* Copyright Arm Limited 2018\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n*/\n\nimport { Transport } from \"../transport\";\nimport { Proxy, CmsisDAP, DAPOperation } from \"../proxy\";\nimport { DPRegister, APRegister, CSWMask, BankSelectMask, AbortMask, CtrlStatMask } from \"./enums\";\nimport { DAP } from \"./\";\nimport { DAPTransferMode, DAPPort, DAPProtocol } from \"../proxy/enums\";\nimport { DEFAULT_CLOCK_FREQUENCY } from \"../proxy/cmsis-dap\";\n\n/**\n * @hidden\n */\nconst MAX_BLOCK_COUNT = 1024;\n/**\n * @hidden\n */\nconst MAX_BLOCK_ADDRESS_MASK = 0x3FF;\n\n/**\n * Arm Debug Interface class\n */\nexport class ADI implements DAP {\n\n    private selectedAddress?: number;\n    private cswValue?: number;\n    private proxy: Proxy;\n\n    /**\n     * ADI constructor\n     * @param transport Debug transport to use\n     * @param mode Debug mode to use\n     * @param clockFrequency Communication clock frequency to use (default 10000000)\n     */\n    constructor(transport: Transport, mode: DAPProtocol, clockFrequency: number);\n    /**\n     * ADI constructor\n     * @param proxy Proxy to use\n     */\n    constructor(proxy: Proxy);\n    constructor(transportOrDap: Transport | Proxy, mode: DAPProtocol = DAPProtocol.DEFAULT, clockFrequency: number = DEFAULT_CLOCK_FREQUENCY) {\n        function isTransport(test: Transport | Proxy): test is Transport {\n            return (test as Transport).open !== undefined;\n        }\n        this.proxy = isTransport(transportOrDap) ? new CmsisDAP(transportOrDap, mode, clockFrequency) : transportOrDap;\n    }\n\n    protected delay(timeout: number): Promise<void> {\n        return new Promise((resolve, _reject) => {\n            setTimeout(resolve, timeout);\n        });\n    }\n\n    /**\n     * Continually run a function until it returns true\n     * @param fn The function to run\n     * @param timer The milliseconds to wait between each run\n     * @param timeout Optional timeout to wait before giving up and rejecting\n     * @returns Promise\n     */\n    protected waitDelay(fn: () => Promise<boolean>, timer: number = 100, timeout: number = 0): Promise<void> {\n        let running: boolean = true;\n\n        const chain = (condition: boolean): Promise<void> => {\n            if (!running) return Promise.resolve();\n            return condition\n                ? Promise.resolve()\n                : this.delay(timer)\n                .then(fn)\n                .then(chain);\n        };\n\n        return new Promise((resolve, reject) => {\n            if (timeout > 0) {\n                setTimeout(() => {\n                    running = false;\n                    reject(\"Wait timed out\");\n                }, timeout);\n            }\n\n            return chain(false)\n            .then(() => resolve());\n        });\n    }\n\n    protected concatTypedArray(arrays: Uint32Array[]): Uint32Array {\n        // Only one array exists\n        if (arrays.length === 1) return arrays[0];\n\n        // Determine array length\n        let length: number = 0;\n        for (const array of arrays) {\n            length += array.length;\n        }\n\n        // Concat the arrays\n        const result = new Uint32Array(length);\n        for (let i = 0, j = 0; i < arrays.length; i++) {\n            result.set(arrays[i], j);\n            j += arrays[i].length;\n        }\n\n        return result;\n    }\n\n    protected readDPCommand(register: number): DAPOperation[] {\n        return [{\n            mode: DAPTransferMode.READ,\n            port: DAPPort.DEBUG,\n            register\n        }];\n    }\n\n    protected writeDPCommand(register: number, value: number): DAPOperation[] {\n        if (register === DPRegister.SELECT) {\n            if (value === this.selectedAddress) {\n                return [];\n            }\n            this.selectedAddress = value;\n        }\n\n        return [{\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.DEBUG,\n            register,\n            value\n        }];\n    }\n\n    protected readAPCommand(register: number): DAPOperation[] {\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.READ,\n            port: DAPPort.ACCESS,\n            register\n        });\n    }\n\n    protected writeAPCommand(register: number, value: number): DAPOperation[] {\n        if (register === APRegister.CSW) {\n            if (value === this.cswValue) {\n                return [];\n            }\n            this.cswValue = value;\n        }\n\n        const address = (register & BankSelectMask.APSEL) | (register & BankSelectMask.APBANKSEL);\n\n        return this.writeDPCommand(DPRegister.SELECT, address).concat({\n            mode: DAPTransferMode.WRITE,\n            port: DAPPort.ACCESS,\n            register,\n            value\n        });\n    }\n\n    protected readMem16Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem16Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_16)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.writeAPCommand(APRegister.DRW, value));\n    }\n\n    protected readMem32Command(register: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.readAPCommand(APRegister.DRW));\n    }\n\n    protected writeMem32Command(register: number, value: number): DAPOperation[] {\n        return this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32)\n        .concat(this.writeAPCommand(APRegister.TAR, register))\n        .concat(this.writeAPCommand(APRegister.DRW, value as number));\n    }\n\n    protected transferSequence(operations: DAPOperation[][]): Promise<Uint32Array> {\n        // Flatten operations into single array\n        let merged: DAPOperation[] = [];\n        merged = merged.concat(...operations);\n\n        let chain: Promise<Uint32Array[]> = Promise.resolve([]);\n\n        // Split operations into sequences no longer than operation count\n        while (merged.length) {\n            const sequence = merged.splice(0, this.proxy.operationCount);\n            chain = chain.then(results => this.proxy.transfer(sequence).then(result => [...results, result]));\n        }\n\n        return chain\n        .then(arrays => this.concatTypedArray(arrays));\n    }\n\n    /**\n     * Connect to target device\n     * @returns Promise\n     */\n    public connect() {\n        const mask = CtrlStatMask.CDBGPWRUPACK | CtrlStatMask.CSYSPWRUPACK;\n\n        return this.proxy.connect()\n        .then(() => this.readDP(DPRegister.DPIDR))\n        .then(() => this.transferSequence([\n            this.writeDPCommand(DPRegister.ABORT, AbortMask.STKERRCLR), // clear sticky error\n            this.writeDPCommand(DPRegister.SELECT, APRegister.CSW), // select CTRL_STAT\n            this.writeDPCommand(DPRegister.CTRL_STAT, CtrlStatMask.CSYSPWRUPREQ | CtrlStatMask.CDBGPWRUPREQ)\n        ]))\n        // Wait until system and debug have powered up\n        .then(() => this.waitDelay(() => {\n            return this.readDP(DPRegister.CTRL_STAT)\n            .then(status => ((status & mask) === mask));\n        }));\n    }\n\n    /**\n     * Disconnect from target device\n     * @returns Promise\n     */\n    public disconnect(): Promise<void> {\n        return this.proxy.disconnect();\n    }\n\n    /**\n     * Reconnect to target device\n     * @returns Promise\n     */\n    public reconnect(): Promise<void> {\n        return this.disconnect()\n        .then(() => this.delay(100))\n        .then(() => this.connect());\n    }\n\n    /**\n     * Reset target device\n     * @returns Promise\n     */\n    public reset(): Promise<boolean> {\n        return this.proxy.reset();\n    }\n\n    /**\n     * Read from a debug port register\n     * @param register DP register to read\n     * @returns Promise of register value\n     */\n    public readDP(register: DPRegister): Promise<number> {\n        return this.proxy.transfer(this.readDPCommand(register))\n        .then(result => result[0]);\n    }\n\n    /**\n     * Write to a debug port register\n     * @param register DP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public writeDP(register: DPRegister, value: number): Promise<void> {\n        return this.proxy.transfer(this.writeDPCommand(register, value))\n        .then(() => undefined);\n    }\n\n    /**\n     * Read from an access port register\n     * @param register AP register to read\n     * @returns Promise of register value\n     */\n    public readAP(register: APRegister): Promise<number> {\n        return this.proxy.transfer(this.readAPCommand(register))\n        .then(result => result[0]);\n    }\n\n    /**\n     * Write to an access port register\n     * @param register AP register to write\n     * @param value Value to write\n     * @returns Promise\n     */\n    public writeAP(register: APRegister, value: number): Promise<void> {\n        return this.proxy.transfer(this.writeAPCommand(register, value))\n        .then(() => undefined);\n    }\n\n    /**\n     * Read a 16-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public readMem16(register: number): Promise<number> {\n        return this.proxy.transfer(this.readMem16Command(register))\n        .then(result => result[0]);\n    }\n\n    /**\n     * Write a 16-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public writeMem16(register: number, value: number): Promise<void> {\n        value = value as number << ((register & 0x02) << 3);\n        return this.proxy.transfer(this.writeMem16Command(register, value))\n        .then(() => undefined);\n    }\n\n    /**\n     * Read a 32-bit word from a memory access port register\n     * @param register ID of register to read\n     * @returns Promise of register data\n     */\n    public readMem32(register: number): Promise<number> {\n        return this.proxy.transfer(this.readMem32Command(register))\n        .then(result => result[0]);\n    }\n\n    /**\n     * Write a 32-bit word to a memory access port register\n     * @param register ID of register to write to\n     * @param value The value to write\n     * @returns Promise\n     */\n    public writeMem32(register: number, value: number): Promise<void> {\n        return this.proxy.transfer(this.writeMem32Command(register, value))\n        .then(() => undefined);\n    }\n\n    /**\n     * Read a block of 32-bit words from a memory access port register\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    public readBlock(register: number, count: number): Promise<Uint32Array> {\n        let chain: Promise<Uint32Array[]> = this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register),\n        ])\n        .then(() => []);\n\n        // Split into requests no longer than block size\n        let remainder = count;\n        while (remainder > 0) {\n            const chunkSize = Math.min(remainder, Math.floor(this.proxy.blockSize / 4));\n            chain = chain.then(results => this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunkSize)\n            .then(result => [...results, result]));\n            remainder -= chunkSize;\n        }\n\n        return chain\n        .then(arrays => this.concatTypedArray(arrays));\n    }\n\n    /**\n     * Write a block of 32-bit words to a memory access port register\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    public writeBlock(register: number, values: Uint32Array): Promise<void> {\n        let chain: Promise<void> = this.transferSequence([\n            this.writeAPCommand(APRegister.CSW, CSWMask.VALUE | CSWMask.SIZE_32),\n            this.writeAPCommand(APRegister.TAR, register),\n        ])\n        .then(() => undefined);\n\n        // Split values into chunks no longer than block size\n        let index = 0;\n        while (index < values.length) {\n            const chunk = values.slice(index, index + Math.floor(this.proxy.blockSize / 4));\n            chain = chain.then(() => this.proxy.transferBlock(DAPPort.ACCESS, APRegister.DRW, chunk));\n            index += Math.floor(this.proxy.blockSize / 4);\n        }\n\n        return chain;\n    }\n\n    /**\n     * read big Block(>1K Uint32Array) from target\n     * @param register ID of register to read from\n     * @param count The count of values to read\n     * @returns Promise of register data\n     */\n    public readBigBlock(register: number, count: number): Promise<Uint32Array> {\n        let chain: Promise<Uint32Array[]> = Promise.resolve([]);\n        // split big block to 1K Uint32Array chunks\n        let remainder = count;\n        let index = 0;\n        while (remainder > 0) {\n            const readRegister = register + index * 4;\n            const maxBlockCount = MAX_BLOCK_COUNT - ((readRegister >> 2) & MAX_BLOCK_ADDRESS_MASK);\n            const chunkSize = Math.min(remainder, maxBlockCount);\n            chain = chain.then(results => this.readBlock(readRegister, chunkSize).then(result => [...results, result]));\n            remainder -= chunkSize;\n            index += chunkSize;\n        }\n        return chain\n        .then(arrays => this.concatTypedArray(arrays));\n    }\n\n    /**\n     * write big Block(>1K Uint32Array) the target\n     * @param register ID of register to write to\n     * @param values The values to write\n     * @returns Promise\n     */\n    public writeBigBlock(register: number, values: Uint32Array): Promise<void> {\n        let chain: Promise<void> = Promise.resolve();\n        // split big block to 1K Uint32Array chunks\n        let index = 0;\n        while (index < values.length) {\n            const writeRegister = register + index * 4;\n            const maxBlockCount = MAX_BLOCK_COUNT - ((writeRegister >> 2) & MAX_BLOCK_ADDRESS_MASK);\n            const chunk = values.slice(index, index + maxBlockCount);\n            chain = chain.then(() => this.writeBlock(writeRegister, chunk));\n            index += maxBlockCount;\n        }\n        return chain;\n    }\n}\n"],"sourceRoot":"../../src"}